void daemon_mode(void)
{
    int fr = 0;

    fr = fork();
    if(fr < 0) {
        fprintf(stderr, "fork() failed\n");
        exit(1);
    }
    if(fr > 0) {
        exit(0);
    }

    if(setsid() < 0) {
        fprintf(stderr, "setsid() failed\n");
        exit(1);
    }

    fr = fork();
    if(fr < 0) {
        fprintf(stderr, "fork() failed\n");
        exit(1);
    }
    if(fr > 0) {
        fprintf(stderr, "forked to background (%d)\n", fr);
        exit(0);
    }

    umask(0); // //设置守护进程的文件权限创建掩码

    fr = chdir("/");  //将当前工作目录更改为根目录
    if(fr != 0) {
        fprintf(stderr, "chdir(/) failed\n");
        exit(0);
    }

    close(0);
    close(1);
    close(2);

    open("/dev/null", O_RDWR);

    fr = dup(0);
    fr = dup(0);
}

///////////////////////////////////////////////
编程规则
在编写精灵进程程序时需遵循一些基本规则，以便防止产生并不希望的交互作用。下面先
说明这些规则，然后是一个按照规则编写的函数d a e m o n _ i n i t。
(1) 首先做的是调用f o r k，然后使父进程e x i t。这样做实现了下面几点：第一，如果该精灵
进程是由一条简单s h e l l命令起动的，那么使父进程终止使得s h e l l认为这条命令已经执行完成。
第二，子进程继承了父进程的进程组I D，但具有一个新的进程I D，这就保证了子进程不是一个
进程组的首进程。这对于下面就要做的s e t s i d调用是必要的前提条件。
(2) 调用s e t s i d以创建一个新对话期。于是执行9 . 5节中列举的三个操作，使调用进程：（a）
成为新对话期的首进程，（b）成为一个新进程组的首进程，（c）没有控制终端。
在S V R之下，有些人建议在此时再调用f o r k，并使父进程终止。第二个子进
程作为精灵进程继续运行。这样就保证了该精灵进程不是对话期首进程，于是按
照S V R 4规则（见9 . 6节）可以防止它取得控制终端。另一方面，为了避免取得控
制终端，无论何时打开一个中断设备都要指定O _ N O C T T Y。
(3) 将当前工作目录更改为根目录。从父进程继承过来的当前工作目录可能在一个装配的
文件系统中。因为精灵进程通常在系统再引导之前是一直存在的，所以如果精灵进程的当前工
作目录在一个装配文件系统中，那么该文件系统就不能被拆卸。
另外，某些精灵进程可能会把当前工作目录更改到某个指定位置，在此位置做它们的工作。
例如，行式打印机假脱机精灵进程常常将其工作目录更改到它们的s p o o l目录上。
(4) 将文件方式创建屏蔽字设置为0。由继承得来的文件方式创建屏蔽字可能会拒绝设置某
些许可权。例如，若精灵进程要创建一个组可读、写的文件，而继承的文件方式创建屏蔽字，
屏蔽了这两种许可权，则所要求的组可读、写就不能起作用。
(5) 关闭不再需要的文件描述符。这样使精灵进程就不再持有从其父进程继承来的某些文
件描述符（父进程可能是s h e l l进程，或某个其他进程）。但是，究竟关闭哪些描述符则与具体
的精灵进程有关，所以在下面的例子中不包含此步骤。可以使用程序2 - 3中的o p e n _ m a x函数来
决定最高文件描述符值，并关闭直到该值的所有描述符。

为什么要fork两次：
1、daemon程序第一次fork后，父进程即退出，这一步就已经把子进程的父进程改成init了，不再是僵死进程
2、之后通过setsid的方法，使其成为会话组的首进程
3、再fork，父进程（步骤1中子进程）退出，这个时候是为了防止自动获取控制终端，非会话组首进程（子进程）无法自动获得控制终端

